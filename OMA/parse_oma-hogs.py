"""
Parse OMA's Hierarchical Orthologous Groups in OrthoXML into tab-delimited files.

Usage:
  parse_oma-hogs.py -h | --help
  parse_oma-hogs.py -v | --version
  parse_oma-hogs.py [-g OUTFILE] [-c OUTFILE] INFILE

Arguments:
  INFILE          Input file in OrthoXML format.

Options:
  -h, --help
  -v, --version
  -g OUTFILE      Output file containing gene/protein IDs [default: oma-hogs_gids.tdv].
  -c OUTFILE      Output file containing hierarchical clusters [default: oma-hogs.tdv].

"""

from lxml import etree
from docopt import docopt

__author__  = 'Arnold Kuzniar'
__version__ = 0.1
__status__  = 'Prototype'
__license__ = 'Apache License, Version 2.0'

#
# Example input:
#   ...
#   <gene id="1" protId="hsa1" />
#   ...
#   <gene id="2" protId="ptr1" />
#   ...
#   <gene id="3" protId="mmu1" />
#   ...
#   <gene id="4" protId="mmu2" />
#   ...
#   <orthologGroup>
#     <orthologGroup>
#       <property name="TaxRange" value="Primates" />
#       <geneRef id="1" />
#       <geneRef id="2" />
#     </orthologGroup>
#     <paralogGroup>
#       <geneRef id="3" />
#       <geneRef id="4" />
#     </paralogGroup>
#   </orthologGroup>
#   ...
#
# Output file 1:
#   gene_id prot_id
#   1   hsa1
#   2   ptr1
#   3   mmu1
#   4   mmu2
#
# Output file 2:
#   hog_id  hog_size    hog_meta    prot_id_1   prot_id_2...
#   1.1	    2   orthologGroup:Primates	hsa1	ptr1
#   1.2	    2   paralogGroup	mmu1	mmu2
#
#   Notes:
#     hog_ids follow a hierarchical numbering scheme (x.y.z...) and
#     are generated by this script as these IDs are not in the *.orthoXML file.
#
#     hog_meta = group_type:taxon where group_type = orthologGroup | paralogGroup
#

if __name__ == '__main__':
    args = docopt(__doc__, version=__version__)
    #print(args)

    infile = args['INFILE']
    outfile_gids = args['-g']
    outfile_hcls = args['-c']
    ORTHO_NS = 'http://orthoXML.org/2011/'
    max_depth = 0
    cur_depth = 0
    id2pid = dict()
    cls_mem = dict()
    cls_meta = dict()
    cls_ids = [0]

    # write gene/protein IDs outfile
    fout_gids = open(outfile_gids, 'w')
    fout_gids.write('# gene_id<tab>prot_id\n') # header line

    # parse XML file for specific tags/attributes:
    #   <gene>, <orthologGroup>, <paralogGroup>, <property>, <geneRef>
    for evt, elem in etree.iterparse(infile, events=['start','end']):
        if elem.tag == '{%s}gene' % ORTHO_NS and evt == 'start':
            id, pid = elem.get('id'), elem.get('protId')
            #gid = elem.get('geneId')
            id2pid[id] = pid
            fout_gids.write('%s\t%s\n' % (id, id2pid[id]))

        if elem.tag == '{%s}orthologGroup' % ORTHO_NS or elem.tag == '{%s}paralogGroup' % ORTHO_NS:
            if evt == 'start':
                cls_ids[cur_depth] += 1
                cur_depth += 1

                if cur_depth > max_depth:
                    max_depth = cur_depth

                cls_ids.append(0)
                cls_id = '.'.join([ str(id) for id in cls_ids[0:cur_depth]])

                if cls_id not in cls_mem:
                    cls_mem[cls_id] = []

                if cls_id not in cls_meta:
                    cls_meta[cls_id] = elem.tag.replace('{%s}' % ORTHO_NS, '')

            if evt == 'end':
                cur_depth -= 1
                cls_ids.pop()
                cls_id = '.'.join([ str(id) for id in cls_ids[0:cur_depth]])

        if elem.tag == '{%s}property' % ORTHO_NS:
            if elem.get('name') == 'TaxRange':
                meta = cls_meta[cls_id]
                if ':' not in meta:
                    cls_meta[cls_id] = "%s:%s" % (meta, elem.get('value')) # group_type:taxon

        if elem.tag == '{%s}geneRef' % ORTHO_NS:
            if evt == 'start':
                if cls_id in cls_mem:
                    cls_mem[cls_id].append(elem.get('id'))

    fout_gids.close()
 
    # write HOGs members outfile
    fout_hcls = open(outfile_hcls, 'w')
    fout_hcls.write('# hog_id<tab>hog_size<tab>hog_meta<tab>prot_id_1<tab>...\n') # header line

    for cls_id, mems in cls_mem.iteritems():
        cls_sz = len(mems)

        if cls_sz > 0:
            arr = [cls_id, cls_sz, cls_meta[cls_id]] + [ id2pid[id] for id in mems ]
            fout_hcls.write('%s\n' % '\t'.join([ str(e) for e in arr ]))
        #else: # why some groups are empty???
        #    fout_hcls.write('%s\n' % cls_id)

    fout_hcls.close()

#    print 'MaxTreeDepth = %d' % max_depth

